import type { VqResultsSnapshot } from "./types";
import { parseVqResultsDataJs } from "./parser";

const HOMEPAGE_URL = "https://rigaya.github.io/vq_results/";
const DATA_URL = "https://rigaya.github.io/vq_results/results/vq_results_data.js";

// Optional: ship a prebuilt unified snapshot (e.g. generated by scripts/vq-results/build-quality-snapshot.mjs)
// as a static asset at this URL. When present, it is preferred over live fetching.
const LOCAL_UNIFIED_SNAPSHOT_URL = "/vq/quality_snapshot.json";

const CACHE_KEY = "ffui.vqResults.cache.v2";

let inFlight: Promise<VqResultsSnapshot> | null = null;
let lastFailureAtMs = 0;
let lastFailureMessage = "";

const isValidSnapshot = (v: unknown): v is VqResultsSnapshot => {
  const s = v as VqResultsSnapshot;
  return !!s && Array.isArray(s.datasets) && s.datasets.length > 0 && typeof s.source?.fetchedAtIso === "string";
};

const safeJsonParse = <T>(raw: string): T | null => {
  try {
    return JSON.parse(raw) as T;
  } catch {
    return null;
  }
};

const extractTitle = (html: string): string | null => {
  const m = (html ?? "").match(/<title>([^<]+)<\/title>/i);
  return m?.[1]?.trim() ?? null;
};

const fetchText = async (url: string): Promise<string> => {
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) throw new Error(`fetch failed: ${res.status} ${res.statusText}`);
  return await res.text();
};

export const loadVqResultsSnapshot = async (options?: { refresh?: boolean }): Promise<VqResultsSnapshot> => {
  const refresh = options?.refresh === true;

  if (!refresh) {
    const now = Date.now();
    if (lastFailureAtMs > 0 && now - lastFailureAtMs < 10_000) {
      throw new Error(lastFailureMessage || "quality snapshot fetch recently failed");
    }
  }

  if (!refresh) {
    const cachedRaw = localStorage.getItem(CACHE_KEY);
    if (cachedRaw) {
      const cached = safeJsonParse<VqResultsSnapshot>(cachedRaw);
      if (cached && isValidSnapshot(cached)) {
        return cached;
      }
    }
  }

  if (!refresh && inFlight) {
    return await inFlight;
  }

  const task = (async () => {
    if (!refresh) {
      try {
        const localRaw = await fetchText(LOCAL_UNIFIED_SNAPSHOT_URL);
        const local = safeJsonParse<VqResultsSnapshot>(localRaw);
        if (local && isValidSnapshot(local)) {
          try {
            localStorage.setItem(CACHE_KEY, JSON.stringify(local));
          } catch {
            // Ignore quota errors; snapshot will still be kept in memory by callers.
          }
          return local;
        }
      } catch {
        // Ignore 404/offline; fall back to live fetching.
      }
    }

    const [homeHtml, dataJs] = await Promise.all([fetchText(HOMEPAGE_URL), fetchText(DATA_URL)]);
    const datasets = parseVqResultsDataJs(dataJs);
    const snapshot: VqResultsSnapshot = {
      source: {
        homepageUrl: HOMEPAGE_URL,
        dataUrl: DATA_URL,
        title: extractTitle(homeHtml),
        fetchedAtIso: new Date().toISOString(),
      },
      datasets,
    };

    try {
      localStorage.setItem(CACHE_KEY, JSON.stringify(snapshot));
    } catch {
      // Ignore quota errors; snapshot will still be kept in memory by callers.
    }

    return snapshot;
  })();

  inFlight = refresh ? null : task;
  try {
    const result = await task;
    lastFailureAtMs = 0;
    lastFailureMessage = "";
    return result;
  } catch (err: unknown) {
    lastFailureAtMs = Date.now();
    lastFailureMessage = err instanceof Error ? err.message : String(err ?? "Unknown error");
    throw err;
  } finally {
    if (inFlight === task) inFlight = null;
  }
};
