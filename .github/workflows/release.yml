name: publish

on:
  # 手动触发，便于在本地验证通过后再发布
  workflow_dispatch:
  # 推送以 v 开头的标签时自动构建并创建 Release，例如 v0.1.0
  push:
    tags:
      - "v*"

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

jobs:
  prepare-release:
    name: prepare-release
    permissions:
      contents: write
    runs-on: ubuntu-22.04
    outputs:
      release_id: ${{ steps.prepare.outputs.release_id }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate curated release notes (bilingual)
        shell: bash
        run: |
          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            if [[ "${GITHUB_REF}" != refs/tags/v* ]]; then
              echo "Manual publish requires selecting a v* tag ref (got: ${GITHUB_REF})" >&2
              exit 1
            fi
          fi

          file="releases/${GITHUB_REF_NAME}.md"
          if [ ! -f "$file" ]; then
            echo "Missing release notes file: $file" >&2
            echo "Create it (and rewrite it) before tagging, e.g.:" >&2
            echo "  node scripts/generate-release-notes.mjs \"${GITHUB_REF_NAME}\" \"<previousTag>\" > \"$file\"" >&2
            exit 1
          fi

          if ! grep -qE '^##[[:space:]]+English([[:space:]]|$)' "$file"; then
            echo "Release notes must include a '## English' section: $file" >&2
            exit 1
          fi

          if ! grep -qE '^##[[:space:]]+中文([[:space:]]|$)' "$file"; then
            echo "Release notes must include a '## 中文' section: $file" >&2
            exit 1
          fi

      - name: Create or update draft release
        id: prepare
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          tag="${GITHUB_REF_NAME}"
          file="releases/${tag}.md"
          target="$(git rev-parse "${tag}^{commit}")"
          title="FFUI ${tag}"

          if gh release view "$tag" --repo "${GITHUB_REPOSITORY}" >/dev/null 2>&1; then
            gh release edit "$tag" \
              --repo "${GITHUB_REPOSITORY}" \
              --draft \
              --title "$title" \
              --notes-file "$file" \
              --target "$target"
          else
            gh release create "$tag" \
              --repo "${GITHUB_REPOSITORY}" \
              --draft \
              --title "$title" \
              --notes-file "$file" \
              --target "$target"
          fi

          release_id="$(gh release view "$tag" --repo "${GITHUB_REPOSITORY}" --json databaseId -q .databaseId)"
          echo "release_id=$release_id" >> "$GITHUB_OUTPUT"

  publish-tauri:
    needs: prepare-release
    permissions:
      contents: write

    strategy:
      fail-fast: false
      matrix:
        platform: [macos-latest, ubuntu-22.04, windows-latest]

    runs-on: ${{ matrix.platform }}
    timeout-minutes: 90

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies (Ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*
          cache: npm

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          # 仅缓存 Tauri 后端的 target 目录
          workspaces: "./src-tauri -> target"

      - name: Cache Tauri tooling downloads
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/tauri
            ~/Library/Caches/tauri
            ~/AppData/Local/tauri
          key: tauri-tools-${{ runner.os }}-v1
          restore-keys: |
            tauri-tools-${{ runner.os }}-

      - name: Install frontend dependencies
        # 项目使用 package-lock.json，因此优先使用 npm ci 以获得更稳定的依赖版本
        run: npm ci

      - name: Validate release version and tag
        shell: bash
        run: |
          tauri_version="$(node -e "const fs = require('node:fs'); console.log(JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json','utf8')).version)")"
          npm_version="$(node -e "const fs = require('node:fs'); console.log(JSON.parse(fs.readFileSync('package.json','utf8')).version)")"

          if [ "${GITHUB_EVENT_NAME}" = "workflow_dispatch" ]; then
            if [[ "${GITHUB_REF}" != refs/tags/v* ]]; then
              echo "Manual publish requires selecting a v* tag ref (got: ${GITHUB_REF})" >&2
              exit 1
            fi
          fi

          if [ -z "$tauri_version" ] || [ -z "$npm_version" ]; then
            echo "Failed to read versions from src-tauri/tauri.conf.json and/or package.json" >&2
            exit 1
          fi

          if [ "$tauri_version" != "$npm_version" ]; then
            echo "Version mismatch: src-tauri/tauri.conf.json=$tauri_version, package.json=$npm_version" >&2
            exit 1
          fi

          if [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            expected="v${tauri_version}"
            if [ "${GITHUB_REF_NAME}" != "$expected" ]; then
              echo "Tag/version mismatch: ref=${GITHUB_REF_NAME}, expected=${expected}" >&2
              exit 1
            fi
          fi

      - name: Validate updater signing configuration
        shell: bash
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        run: |
          if [ -z "${TAURI_SIGNING_PRIVATE_KEY}" ]; then
            echo "Missing secret: TAURI_SIGNING_PRIVATE_KEY (required for updater signatures)." >&2
            echo "Generate it with: npm run tauri -- signer generate -w ~/.tauri/ffui-updater.key --ci" >&2
            echo "Then set the GitHub Actions secret to the private key content or path." >&2
            exit 1
          fi

          pubkey="$(node -e "const fs=require('node:fs'); const cfg=JSON.parse(fs.readFileSync('src-tauri/tauri.conf.json','utf8')); console.log(cfg?.plugins?.updater?.pubkey ?? '')")"
          if [ -z "${pubkey}" ] || [ "${pubkey}" = "REPLACE_WITH_TAURI_UPDATER_PUBLIC_KEY" ]; then
            echo "Updater pubkey is not configured in src-tauri/tauri.conf.json." >&2
            echo "Set plugins.updater.pubkey to the public key string generated by 'tauri signer generate'." >&2
            exit 1
          fi

      - name: Build and release with Tauri
        id: tauri
        uses: tauri-apps/tauri-action@v1
        env:
          # GitHub 默认提供的 token，用于创建 Release 与上传构建产物
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Required for updater signatures (do not commit private keys).
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          releaseId: ${{ needs.prepare-release.outputs.release_id }}
          retryAttempts: 3
          # __VERSION__ 会自动替换为 src-tauri/tauri.conf.json 中的 version 字段
          tagName: v__VERSION__
          releaseDraft: true
          prerelease: false

      - name: Prepare Windows portable exe asset
        if: matrix.platform == 'windows-latest'
        shell: bash
        run: |
          mkdir -p dist-portable
          src="src-tauri/target/release/ffui.exe"
          if [ ! -f "$src" ]; then
            echo "Portable exe not found: $src" >&2
            exit 1
          fi
          out="dist-portable/FFUI-v${{ steps.tauri.outputs.appVersion }}-windows-x64-portable.exe"
          cp "$src" "$out"
          ls -la dist-portable

      - name: Upload Windows portable exe to release
        if: matrix.platform == 'windows-latest'
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.tauri.outputs.appVersion }}
          files: dist-portable/FFUI-v${{ steps.tauri.outputs.appVersion }}-windows-x64-portable.exe
          fail_on_unmatched_files: true
